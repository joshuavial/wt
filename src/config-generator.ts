export interface ConfigData {
  startContainers: boolean;
  portOffsetIncrement: number;
  envFiles: string[];
  portMappings: Array<{ variable: string; port: number }>;
  containerNames: Array<{ variable: string; template: string }>;
  fileUpdates: Array<{
    file: string;
    type: 'env_vars' | 'replace' | 'append';
    spec: string;
    searchPattern?: string;
    replacement?: string;
  }>;
}

export class ConfigGenerator {
  private config: ConfigData;

  constructor(config: ConfigData) {
    this.config = config;
  }

  /**
   * Generate the .wt.conf file content
   */
  toString(): string {
    const lines: string[] = [];

    // Header
    lines.push('# Generated by wt init');
    lines.push(`# Generated on ${new Date().toISOString()}`);
    lines.push('');

    // START_CONTAINERS
    lines.push('# Control whether to start containers automatically');
    lines.push(`START_CONTAINERS=${this.config.startContainers ? 'true' : 'false'}`);
    lines.push('');

    // PORT_OFFSET_INCREMENT
    lines.push('# Port offset increment between worktrees');
    lines.push(`PORT_OFFSET_INCREMENT=${this.config.portOffsetIncrement}`);
    lines.push('');

    // ENV_FILES
    if (this.config.envFiles.length > 0) {
      lines.push('# Environment files to copy to worktrees');
      lines.push('ENV_FILES=(');
      for (const file of this.config.envFiles) {
        lines.push(`    "${file}"`);
      }
      lines.push(')');
      lines.push('');
    }

    // PORT_MAPPINGS
    if (this.config.portMappings.length > 0) {
      lines.push('# Define port mappings for automatic offset');
      lines.push('PORT_MAPPINGS=(');
      for (const mapping of this.config.portMappings) {
        lines.push(`    "${mapping.variable}:${mapping.port}"`);
      }
      lines.push(')');
      lines.push('');
    }

    // CONTAINER_NAMES
    if (this.config.containerNames.length > 0) {
      lines.push('# Define container name templates');
      lines.push('CONTAINER_NAMES=(');
      for (const container of this.config.containerNames) {
        lines.push(`    "${container.variable}:${container.template}"`);
      }
      lines.push(')');
      lines.push('');
    }

    // FILE_UPDATES
    if (this.config.fileUpdates.length > 0) {
      lines.push('# File update rules');
      lines.push('FILE_UPDATES=(');
      for (const update of this.config.fileUpdates) {
        if (update.type === 'env_vars') {
          lines.push(`    "${update.file}|${update.type}|${update.spec}"`);
        } else if (update.type === 'replace' && update.searchPattern && update.replacement) {
          lines.push(`    "${update.file}|${update.type}|${update.searchPattern}|${update.replacement}"`);
        } else if (update.type === 'append') {
          lines.push(`    "${update.file}|${update.type}|${update.spec}"`);
        }
      }
      lines.push(')');
    }

    return lines.join('\n') + '\n';
  }

  /**
   * Format port mappings for display
   */
  static formatPortMappingsDisplay(mappings: Array<{ variable: string; port: number }>): string[] {
    return mappings.map(m => `${m.variable} = ${m.port}`);
  }

  /**
   * Generate container name template from existing name
   */
  static generateContainerTemplate(containerName: string, projectName?: string): string {
    // If the container name already includes the project name, replace it with a placeholder
    if (projectName && containerName.includes(projectName)) {
      return containerName.replace(projectName, '{{PROJECT_NAME}}-{{WORKTREE_NAME}}');
    }
    
    // Otherwise, prepend the worktree name
    return `{{WORKTREE_NAME}}-${containerName}`;
  }

  /**
   * Generate FILE_UPDATES spec for environment variables
   */
  static generateEnvVarsSpec(portVariables: string[]): string {
    return portVariables.join(',');
  }
}